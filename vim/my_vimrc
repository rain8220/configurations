set nocompatible
set autowrite
filetype plugin indent on
set nobackup
set ignorecase
set number
set ruler
set showmatch

"自动缩进
set noautoindent
set cindent
set smartindent

"Tab键的宽度
set shiftwidth=4
set tabstop=4

"使用4个空格代替Tab
set expandtab
set softtabstop=4


" vundle 环境设置
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
" vundle 管理的插件列表必须位于 vundle#begin() 和 vundle#end() 之间
call vundle#begin()
Plugin 'VundleVim/Vundle.vim'
Plugin 'altercation/vim-colors-solarized'
Plugin 'tomasr/molokai'
Plugin 'Lokaltog/vim-powerline'
Plugin 'octol/vim-cpp-enhanced-highlight'
" 可以快速对齐的插件
Plugin 'junegunn/vim-easy-align'
" 用来提供一个导航目录的侧边栏
Plugin 'scrooloose/nerdtree'
" 可以使 nerdtree 的 tab 更加友好些
Plugin 'jistr/vim-nerdtree-tabs'
" 可以在导航目录中看到 git 版本信息
Plugin 'Xuyuanp/nerdtree-git-plugin'
" 查看当前代码文件中的变量和函数列表的插件，
" 可以切换和跳转到代码中对应的变量和函数的位置
" 大纲式导航, Go 需要 https://github.com/jstemmer/gotags 支持
Plugin 'majutsushi/tagbar'
" 自动补全括号的插件，包括小括号，中括号，以及花括号
Plugin 'jiangmiao/auto-pairs'
" Vim状态栏插件，包括显示行号，列号，文件类型，文件名，以及Git状态
Plugin 'vim-airline/vim-airline'
" Airline主题
Plugin 'vim-airline/vim-airline-themes'
" 代码自动完成，安装完插件还需要额外配置才可以使用
Plugin 'Valloric/YouCompleteMe'
" 可以在文档中显示 git 信息
Plugin 'airblade/vim-gitgutter'
" 下面两个插件要配合使用，可以自动生成代码块
Plugin 'SirVer/ultisnips'
Plugin 'honza/vim-snippets'
" 可以在 vim 中使用 tab 补全
Plugin 'vim-scripts/SuperTab'
" 可以在 vim 中自动完成
" Plugin 'Shougo/neocomplete.vim'
" go 主要插件
Plugin 'fatih/vim-go'
" go 中的代码追踪，输入 gd 就可以自动跳转
Plugin 'dgryski/vim-godef'
call vundle#end()
" end of vundle 插件设置

" 语法
filetype plugin indent on
syntax enable
syntax on

" 配色方案
set background=dark
"colorscheme solarized
colorscheme molokai
"colorscheme phd

" ======================================================================
" 状态栏配置
" ======================================================================
" 总是显示状态栏
set laststatus=2
" 选择状态栏主题
let g:airline_theme='base16'
" 显示窗口tab和buffer
let g:airline#extensions#tabline#enabled = 1


" 高亮显示当前行/列
" set cursorline
set cursorcolumn
" 高亮显示搜索结果
" set hlsearch
" 退出插入模式指定类型的文件自动保存
au InsertLeave *.go,*.sh,*.c,*.cc,*.cpp,*.h,*.py write


" ============================================================
" 以下为设置YCM的自动补齐
" =============================================================
let g:ycm_autoclose_preview_window_after_insertion = 0
let g:ycm_autoclose_preview_window_after_completion = 0


" ============================================================
" 以下为设置快捷键
" =============================================================
" 设置 leader 键
let mapleader=";"
" You can add some shortcuts to make it easier to jump between errors in quickfix list
map <C-n> :cnext<CR>
map <C-m> :cprevious<CR>
nnoremap <leader>a :cclose<CR>
" use these shortcuts to build and run a Go program with <leader>b and <leader>r:
" run :GoBuild or :GoTestCompile based on the go file
function! s:build_go_files()
  let l:file = expand('%')
  if l:file =~# '^\f\+_test\.go$'
    call go#test#Test(0, 1)
  elseif l:file =~# '^\f\+\.go$'
    call go#cmd#Build(0)
  endif
endfunction

autocmd FileType go nmap <leader>b :<C-u>call <SID>build_go_files()<CR>
" Now whenever you hit <leader>b it'll build either your Go file or it'll compile your test files seamlessly
autocmd FileType go nmap <leader>r  <Plug>(go-run)
autocmd FileType go nmap <leader>t  <Plug>(go-test)
autocmd FileType go nmap <Leader>c <Plug>(go-coverage-toggle)

" end of 快捷键设置

" ====================================================================
" 解决YCM与ultisnips快捷键的冲突,一般做法是重新设定按键，实际上有更好的办法：
" 主要是把Ultisnips的调用等级调比较高，如果有snippets的时候就会调用Ultisnips，
" 如果没有snippets的时候就会调用YCM的自动补全功能。这样就可以完美的结合了
" 如果有snips，直接按tab键就可以完成添加
" 自动补齐时，使用tab键往下走，shfit+tab键往上走
" ====================================================================

function! g:UltiSnips_Complete()
  call UltiSnips#ExpandSnippet()
  if g:ulti_expand_res == 0
    if pumvisible()
      return "\<C-n>"
    else
      call UltiSnips#JumpForwards()
      if g:ulti_jump_forwards_res == 0
        return "\<TAB>"
      endif
    endif
  endif
  return ""
endfunction

function! g:UltiSnips_Reverse()
  call UltiSnips#JumpBackwards()
  if g:ulti_jump_backwards_res == 0
    return "\<C-P>"
  endif

  return ""
endfunction


if !exists("g:UltiSnipsJumpForwardTrigger")
  let g:UltiSnipsJumpForwardTrigger = "<tab>"
endif
if !exists("g:UltiSnipsJumpBackwardTrigger")
  let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
endif


au InsertEnter * exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=g:UltiSnips_Complete()<cr>"
au InsertEnter * exec "inoremap <silent> " . g:UltiSnipsJumpBackwardTrigger . " <C-R>=g:UltiSnips_Reverse()<cr>"

" =============================================================================
" 设置NerdTree
" F3 switch on/off the NerdTree window
" 多次按"ctrl+w"，光标自动在左右侧窗口切换
" ?: 快速帮助文档
" o: 打开一个目录或者打开文件，创建的是buffer，也可以用来打开书签
" go: 打开一个文件，但是光标仍然留在NERDTree，创建的是buffer
" t: 打开一个文件，创建的是Tab，对书签同样生效
" T: 打开一个文件，但是光标仍然留在NERDTree，创建的是Tab，对书签同样生效
" i: 水平分割创建文件的窗口，创建的是buffer
" gi: 水平分割创建文件的窗口，但是光标仍然留在NERDTree
" s: 垂直分割创建文件的窗口，创建的是buffer
" gs: 和gi，go类似
" x: 收起当前打开的目录
" X: 收起所有打开的目录
" e: 以文件管理的方式打开选中的目录
" D: 删除书签
" P: 大写，跳转到当前根路径
" p: 小写，跳转到光标所在的上一级路径
" K: 跳转到第一个子路径
" J: 跳转到最后一个子路径
" <C-j>和<C-k>: 在同级目录和文件间移动，忽略子目录和子文件
" C: 将根路径设置为光标所在的目录
" u: 设置上级目录为根路径
" U: 设置上级目录为跟路径，但是维持原来目录打开的状态
" r: 刷新光标所在的目录
" R: 刷新当前根路径
" I: 显示或者不显示隐藏文件
" f: 打开和关闭文件过滤器
" q: 关闭NERDTree
" A: 全屏显示NERDTree，或者关闭全屏
" ==============================================================================
map <F3> :NERDTreeMirror<CR>
map <F3> :NERDTreeToggle<CR>
"去除第一行的帮助提示
let NERDTreeMinimalUI=1
"在左边占多宽
let NERDTreeWinSize=30
"不高亮显示光标所在的文件
let NERDTreeHighlightCursorline=0
"当前目录的设定
let NERDTreeChDirMode = 2
"自动退出
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") &&b:NERDTreeType == "primary") | q | endif
"打开vim时自动打开
autocmd vimenter * NERDTree

"==============================================================================
"设置tabgar, 显示在NERDTree的下方
"==============================================================================
map <F4> :TagbarToggle<CR>
"打开文件自动 打开tagbar
autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx,*.go call tagbar#autoopen()
"在这儿设定二者的分布
let g:tagbar_vertical = 30
"去除第一行的帮助信息
let g:tagbar_compact = 1
"当编辑代码时，在Tagbar自动追踪变量
let g:tagbar_autoshowtag = 1
"个人爱好，展开关闭文件夹的图标
let g:tagbar_iconchars = ['▸', '▾']
"打开vim时自动打开
autocmd VimEnter * nested :TagbarOpen
wincmd l
"如果不加这句，打开vim的时候当前光标会在Nerdtree区域
autocmd VimEnter * wincmd l

"==============================================================================
""  nerdtree-git-plugin 插件
"==============================================================================
let g:NERDTreeIndicatorMapCustom = {
    \ "Modified"  : "✹",
    \ "Staged"    : "✚",
    \ "Untracked" : "✭",
    \ "Renamed"   : "➜",
    \ "Unmerged"  : "═",
    \ "Deleted"   : "✖",
    \ "Dirty"     : "✗",
    \ "Clean"     : "✔︎",
    \ 'Ignored'   : '☒',
    \ "Unknown"   : "?"
    \ }

let g:NERDTreeShowIgnoredStatus = 1

" ==============================================================================
" tab 标签页切换快捷键
" ===============================================================================
:nn <Leader>1 1gt
:nn <Leader>2 2gt
:nn <Leader>3 3gt
:nn <Leader>4 4gt
:nn <Leader>5 5gt
:nn <Leader>6 6gt
:nn <Leader>7 7gt
:nn <Leader>8 8gt
:nn <Leader>9 8gt
:nn <Leader>0 :tablast<CR>
